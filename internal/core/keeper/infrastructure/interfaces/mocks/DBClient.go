// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	errors "github.com/edgexfoundry/go-mod-core-contracts/v4/errors"

	mock "github.com/stretchr/testify/mock"

	models "github.com/edgexfoundry/go-mod-core-contracts/v4/models"
)

// DBClient is an autogenerated mock type for the DBClient type
type DBClient struct {
	mock.Mock
}

// AddKeeperKeys provides a mock function with given fields: kv, isFlatten
func (_m *DBClient) AddKeeperKeys(kv models.KVS, isFlatten bool) ([]models.KeyOnly, errors.EdgeX) {
	ret := _m.Called(kv, isFlatten)

	if len(ret) == 0 {
		panic("no return value specified for AddKeeperKeys")
	}

	var r0 []models.KeyOnly
	var r1 errors.EdgeX
	if rf, ok := ret.Get(0).(func(models.KVS, bool) ([]models.KeyOnly, errors.EdgeX)); ok {
		return rf(kv, isFlatten)
	}
	if rf, ok := ret.Get(0).(func(models.KVS, bool) []models.KeyOnly); ok {
		r0 = rf(kv, isFlatten)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.KeyOnly)
		}
	}

	if rf, ok := ret.Get(1).(func(models.KVS, bool) errors.EdgeX); ok {
		r1 = rf(kv, isFlatten)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.EdgeX)
		}
	}

	return r0, r1
}

// AddRegistration provides a mock function with given fields: r
func (_m *DBClient) AddRegistration(r models.Registration) (models.Registration, errors.EdgeX) {
	ret := _m.Called(r)

	if len(ret) == 0 {
		panic("no return value specified for AddRegistration")
	}

	var r0 models.Registration
	var r1 errors.EdgeX
	if rf, ok := ret.Get(0).(func(models.Registration) (models.Registration, errors.EdgeX)); ok {
		return rf(r)
	}
	if rf, ok := ret.Get(0).(func(models.Registration) models.Registration); ok {
		r0 = rf(r)
	} else {
		r0 = ret.Get(0).(models.Registration)
	}

	if rf, ok := ret.Get(1).(func(models.Registration) errors.EdgeX); ok {
		r1 = rf(r)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.EdgeX)
		}
	}

	return r0, r1
}

// DeleteKeeperKeys provides a mock function with given fields: key, isRecurse
func (_m *DBClient) DeleteKeeperKeys(key string, isRecurse bool) ([]models.KeyOnly, errors.EdgeX) {
	ret := _m.Called(key, isRecurse)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKeeperKeys")
	}

	var r0 []models.KeyOnly
	var r1 errors.EdgeX
	if rf, ok := ret.Get(0).(func(string, bool) ([]models.KeyOnly, errors.EdgeX)); ok {
		return rf(key, isRecurse)
	}
	if rf, ok := ret.Get(0).(func(string, bool) []models.KeyOnly); ok {
		r0 = rf(key, isRecurse)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.KeyOnly)
		}
	}

	if rf, ok := ret.Get(1).(func(string, bool) errors.EdgeX); ok {
		r1 = rf(key, isRecurse)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.EdgeX)
		}
	}

	return r0, r1
}

// DeleteRegistrationByServiceId provides a mock function with given fields: id
func (_m *DBClient) DeleteRegistrationByServiceId(id string) errors.EdgeX {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRegistrationByServiceId")
	}

	var r0 errors.EdgeX
	if rf, ok := ret.Get(0).(func(string) errors.EdgeX); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.EdgeX)
		}
	}

	return r0
}

// KeeperKeys provides a mock function with given fields: key, keyOnly, isRaw
func (_m *DBClient) KeeperKeys(key string, keyOnly bool, isRaw bool) ([]models.KVResponse, errors.EdgeX) {
	ret := _m.Called(key, keyOnly, isRaw)

	if len(ret) == 0 {
		panic("no return value specified for KeeperKeys")
	}

	var r0 []models.KVResponse
	var r1 errors.EdgeX
	if rf, ok := ret.Get(0).(func(string, bool, bool) ([]models.KVResponse, errors.EdgeX)); ok {
		return rf(key, keyOnly, isRaw)
	}
	if rf, ok := ret.Get(0).(func(string, bool, bool) []models.KVResponse); ok {
		r0 = rf(key, keyOnly, isRaw)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.KVResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(string, bool, bool) errors.EdgeX); ok {
		r1 = rf(key, keyOnly, isRaw)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.EdgeX)
		}
	}

	return r0, r1
}

// RegistrationByServiceId provides a mock function with given fields: id
func (_m *DBClient) RegistrationByServiceId(id string) (models.Registration, errors.EdgeX) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for RegistrationByServiceId")
	}

	var r0 models.Registration
	var r1 errors.EdgeX
	if rf, ok := ret.Get(0).(func(string) (models.Registration, errors.EdgeX)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(string) models.Registration); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(models.Registration)
	}

	if rf, ok := ret.Get(1).(func(string) errors.EdgeX); ok {
		r1 = rf(id)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.EdgeX)
		}
	}

	return r0, r1
}

// Registrations provides a mock function with no fields
func (_m *DBClient) Registrations() ([]models.Registration, errors.EdgeX) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Registrations")
	}

	var r0 []models.Registration
	var r1 errors.EdgeX
	if rf, ok := ret.Get(0).(func() ([]models.Registration, errors.EdgeX)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []models.Registration); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Registration)
		}
	}

	if rf, ok := ret.Get(1).(func() errors.EdgeX); ok {
		r1 = rf()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.EdgeX)
		}
	}

	return r0, r1
}

// UpdateRegistration provides a mock function with given fields: r
func (_m *DBClient) UpdateRegistration(r models.Registration) errors.EdgeX {
	ret := _m.Called(r)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRegistration")
	}

	var r0 errors.EdgeX
	if rf, ok := ret.Get(0).(func(models.Registration) errors.EdgeX); ok {
		r0 = rf(r)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.EdgeX)
		}
	}

	return r0
}

// NewDBClient creates a new instance of DBClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDBClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *DBClient {
	mock := &DBClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
